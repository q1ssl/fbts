[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Employee Checkin",
  "enabled": 1,
  "modified": "2025-08-30 00:06:34.472251",
  "module": "fbts",
  "name": "Employee Checkin",
  "script": "frappe.ui.form.on('Employee Checkin', {\n    onload(frm) {\n        frappe.realtime.on('refresh_checkin_form', (data) => {\n            if (data.name === frm.doc.name) {\n                frm.reload_doc();  // Refresh only if it's the current doc\n            }\n        });\n    }\n});\n\n\n\n\n\n\n\n\n\n\n\n// frappe.ui.form.on('Employee Checkin', {\n//     after_save: function(frm) {\n//         frappe.call({\n//             method: \"fbts.api.regularise.apply_regularise_time\",\n//             type: \"POST\",\n//             args: {\n//                 name: frm.doc.name,\n//                 custom_status: frm.doc.custom_status\n//             },\n//             callback: function(r) {\n//                 if (!r.exc) {\n//                     frappe.msgprint(\"Status synced.\");\n//                     frm.reload_doc(); // Reload the form after API call\n//                 }\n//             }\n//         });\n//     }\n// });\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Job Offer",
  "enabled": 0,
  "modified": "2025-09-08 21:58:50.505345",
  "module": "fbts",
  "name": "Job Offer 2",
  "script": "frappe.ui.form.on('Job Offer', {\n  async refresh(frm) {\n    if (frm.doc.docstatus === 1) return; // no buttons on Cancelled\n    const email = frm.doc.applicant_email;\n    if (!email) return;\n\n    // ——— USER BUTTONS ———\n    const user_exists = await frappe.db.exists('User', email);\n\n    if (user_exists) {\n      frm.add_custom_button(__('View User'), () => {\n        frappe.set_route('Form', 'User', email);\n      }, __('Actions'));\n    } else {\n      frm.add_custom_button(__('Create User'), async () => {\n        await create_user_from_job_offer(frm);\n        await frm.refresh(); // redraw buttons\n      }, __('Actions'));\n    }\n\n    // ——— USER PERMISSION BUTTONS ———\n    if (!frm.doc.name) return; // need saved doc to tie permission\n    const perm = await frappe.db.get_value(\n      'User Permission',\n      { user: email, allow: 'Job Offer', for_value: frm.doc.name },\n      'name'\n    );\n\n    if (perm?.message?.name) {\n      frm.add_custom_button(__('View User Permission'), () => {\n        frappe.set_route('Form', 'User Permission', perm.message.name);\n      }, __('Actions'));\n    } else {\n      frm.add_custom_button(__('Create User Permission'), async () => {\n        await create_user_permission(frm);\n        await frm.refresh();\n      }, __('Actions'));\n    }\n  }\n});\n\n/** Create User with \"Job Applicant\" role and default UI flags = 0 */\nasync function create_user_from_job_offer(frm) {\n  const email = frm.doc.applicant_email;\n  const name  = frm.doc.applicant_name || '';\n\n  if (!email) {\n    frappe.msgprint(__('Applicant Email is required to create a User.'));\n    return;\n  }\n\n  const exists = await frappe.db.exists('User', email);\n\n  if (!exists) {\n    const r = await frappe.call({\n      method: \"frappe.client.insert\",\n      args: {\n        doc: {\n          doctype: \"User\",\n          email,\n          first_name: name,\n          enabled: 1,\n          user_type: \"Website User\",\n          send_welcome_email: 0,     // set to 1 if you want welcome email\n          new_password: \"fbts@123\",  // optional default password\n          roles: [{ role: \"Job Applicant\" }],\n\n          // Default UI toggles set to 0 at creation\n          search_bar: 0,\n          notifications: 0,\n          list_sidebar: 0,\n          bulk_actions: 0,\n          view_switcher: 0,\n          form_sidebar: 0,\n          timeline: 0,\n          dashboard: 0\n        }\n      }\n    });\n\n    if (r?.message?.name) {\n      frappe.show_alert({ message: __('User created: {0}', [email]), indicator: 'green' });\n    }\n  } else {\n    await ensure_job_applicant_role(email);\n    frappe.show_alert({ message: __('User already exists: {0}', [email]), indicator: 'blue' });\n  }\n}\n\n/** Ensure existing user has the \"Job Applicant\" role */\nasync function ensure_job_applicant_role(email) {\n  const res = await frappe.call({\n    method: \"frappe.client.get\",\n    args: { doctype: \"User\", name: email }\n  });\n  const userDoc = res?.message;\n  if (!userDoc) return;\n\n  const hasRole = Array.isArray(userDoc.roles) && userDoc.roles.some(r => r.role === \"Job Applicant\");\n  if (!hasRole) {\n    userDoc.roles = userDoc.roles || [];\n    userDoc.roles.push({ role: \"Job Applicant\" });\n    await frappe.call({ method: \"frappe.client.save\", args: { doc: userDoc } });\n  }\n}\n\n/** Create User Permission for this Job Offer (idempotent) */\nasync function create_user_permission(frm) {\n  const email = frm.doc.applicant_email;\n  const job_offer_name = frm.doc.name;\n\n  if (!email) {\n    frappe.msgprint(__('Applicant Email is required to create a User Permission.'));\n    return;\n  }\n  if (!job_offer_name) {\n    frappe.msgprint(__('Please save the Job Offer first.'));\n    return;\n  }\n\n  // Check existence with correct filters\n  const exists = await frappe.db.get_value(\n    'User Permission',\n    { user: email, allow: 'Job Offer', for_value: job_offer_name },\n    'name'\n  );\n  if (exists?.message?.name) {\n    frappe.show_alert({ message: __('User Permission already exists for {0}', [email]), indicator: 'blue' });\n    return;\n  }\n\n  await frappe.call({\n    method: 'frappe.client.insert',\n    args: {\n      doc: {\n        doctype: 'User Permission',\n        user: email,\n        allow: 'Job Offer',\n        for_value: job_offer_name,\n        apply_to_all_doctypes: 0,\n        applicable_for: 'Job Offer'\n      }\n    }\n  });\n\n  frappe.show_alert({ message: __('User Permission created for {0}', [email]), indicator: 'green' });\n}\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Job Offer",
  "enabled": 1,
  "modified": "2025-09-08 22:47:29.589478",
  "module": "fbts",
  "name": "Job Offer  Salary Calculation",
  "script": "(() => {\n  const API_METHOD = \"fbts.salary_str.get_salary_structure_components\";\n  const TABLES = { earnings: \"earnings\", deductions: \"deductions\" };\n  const PARENT_BASE_FIELD = \"base\";\n  const CUSTOM_OFFERED_CTC = \"custom_offered_ctc\"; // <-- NEW\n\n  function toFloat(v, precision = null) {\n    if (v === undefined || v === null) return 0;\n    const s = String(v).replace(/[^\\d.\\-]/g, \"\");\n    let n = parseFloat(s);\n    if (isNaN(n)) n = 0;\n    if (precision === null) return n;\n    const m = Math.pow(10, precision);\n    return Math.round(n * m) / m;\n  }\n  function toInt(v) {\n    const n = parseInt(v, 10);\n    return isNaN(n) ? 0 : n;\n  }\n\n  const SAFE_EXPR = /^[0-9+\\-*/()., _a-zA-Z<>!=&|?:%]+$/;\n\n  // Effective base = custom_offered_ctc (if > 0) else base\n  function get_effective_base(frm) {\n    const offered = toFloat(frm.doc[CUSTOM_OFFERED_CTC]);\n    if (offered > 0) return offered;\n    return toFloat(frm.doc[PARENT_BASE_FIELD]);\n  }\n\n  function build_context(frm) {\n    const ctx = { Math, base: get_effective_base(frm) };\n    [TABLES.earnings, TABLES.deductions].forEach((table) => {\n      (frm.doc[table] || []).forEach((row) => {\n        if (row.abbr) ctx[row.abbr] = toFloat(row.amount);\n      });\n    });\n    return ctx;\n  }\n\n  function evaluate_formula(expr, ctx) {\n    if (!expr || typeof expr !== \"string\") return null;\n    if (!SAFE_EXPR.test(expr)) {\n      throw new Error(\"Formula contains unsupported characters.\");\n    }\n    const tokens = Object.keys(ctx).filter((k) => k !== \"Math\");\n    for (const key of tokens) {\n      const re = new RegExp(`\\\\b${key}\\\\b`, \"g\");\n      expr = expr.replace(re, `ctx[\"${key}\"]`);\n    }\n    const fn = new Function(\"ctx\", \"with (ctx) { return (\" + expr + \"); }\");\n    return fn(ctx);\n  }\n\n  // NEW: compute row with option to overwrite existing amounts when we have custom_offered_ctc\n  function compute_row_from_formula(frm, row, ctx, { overwrite = false } = {}) {\n    const isBlankAmount =\n      row.amount === undefined || row.amount === null || row.amount === \"\" || row.amount === 0;\n\n    if (!overwrite && !isBlankAmount) return false;\n    if (!row.formula || !String(row.formula).trim()) return false;\n\n    try {\n      const raw = evaluate_formula(String(row.formula).trim(), ctx);\n      const num = toFloat(raw, 2);\n      const newVal = isNaN(num) ? 0 : num;\n      if (row.amount !== newVal) {\n        row.amount = newVal;\n        if (row.abbr) ctx[row.abbr] = row.amount;\n        return true;\n      }\n      return false;\n    } catch (err) {\n      console.warn(\"Formula evaluation failed:\", row, err);\n      frappe.show_alert({\n        message: `Could not evaluate formula for ${row.abbr || row.salary_component || \"row\"}.`,\n        indicator: \"orange\",\n      });\n      return false;\n    }\n  }\n\n  // NEW: full recompute helper; if custom_offered_ctc > 0, force overwrite all formula rows\n  function recompute_all_amounts(frm) {\n    const forceOverwrite = toFloat(frm.doc[CUSTOM_OFFERED_CTC]) > 0;\n    let ctx = build_context(frm);\n    for (let pass = 0; pass < 5; pass++) {\n      let changed = false;\n      [TABLES.earnings, TABLES.deductions].forEach((table) => {\n        (frm.doc[table] || []).forEach((row) => {\n          const did = compute_row_from_formula(frm, row, ctx, { overwrite: forceOverwrite });\n          if (did) changed = true;\n        });\n      });\n      if (!changed) break;\n      ctx = build_context(frm);\n    }\n    frm.refresh_fields([TABLES.earnings, TABLES.deductions]);\n  }\n\n  const FIELD_MAP = (row) => ({\n    salary_component: row.salary_component,\n    abbr: row.abbr,\n    amount: row.amount,\n    default_amount: row.default_amount,\n    additional_amount: row.additional_amount,\n    amount_based_on_formula: row.amount_based_on_formula,\n    formula: row.formula,\n    condition: row.condition,\n    depends_on_payment_days: row.depends_on_payment_days,\n    is_tax_applicable: row.is_tax_applicable,\n    is_flexible_benefit: row.is_flexible_benefit,\n    variable_based_on_taxable_salary: row.variable_based_on_taxable_salary,\n    statistical_component: row.statistical_component,\n    do_not_include_in_total: row.do_not_include_in_total,\n    deduct_full_tax_on_selected_payroll_date: row.deduct_full_tax_on_selected_payroll_date,\n    tax_on_additional_salary: row.tax_on_additional_salary,\n    tax_on_flexible_benefit: row.tax_on_flexible_benefit,\n    year_to_date: row.year_to_date,\n  });\n\n  function fill_child_table(frm, tablefield, rows) {\n    frm.clear_table(tablefield);\n    (rows || []).forEach((r) => {\n      const child = frm.add_child(tablefield);\n      Object.assign(child, FIELD_MAP(r));\n    });\n    frm.refresh_field(tablefield);\n  }\n\n  async function apply_salary_structure(frm, { overwrite = true } = {}) {\n    const structure = frm.doc.salary_structure;\n    if (!structure) return;\n\n    try {\n      frappe.show_progress(\"Loading\", 30, 100, \"Fetching Salary Structure…\");\n      const { message } = await frappe.call({ method: API_METHOD, args: { structure } });\n\n      if (!message) {\n        frappe.msgprint({\n          title: \"No Data\",\n          message: \"No components returned for the selected Salary Structure.\",\n          indicator: \"orange\",\n        });\n        return;\n      }\n\n      if (message.meta) {\n        if (frm.fields_dict.currency && message.meta.currency) {\n          frm.set_value(\"currency\", message.meta.currency);\n        }\n        if (frm.fields_dict.payroll_frequency && message.meta.payroll_frequency) {\n          frm.set_value(\"payroll_frequency\", message.meta.payroll_frequency);\n        }\n      }\n\n      if (overwrite) {\n        fill_child_table(frm, TABLES.earnings, message.earnings);\n        fill_child_table(frm, TABLES.deductions, message.deductions);\n      } else {\n        (message.earnings || []).forEach((r) => {\n          const child = frm.add_child(TABLES.earnings);\n          Object.assign(child, FIELD_MAP(r));\n        });\n        (message.deductions || []).forEach((r) => {\n          const child = frm.add_child(TABLES.deductions);\n          Object.assign(child, FIELD_MAP(r));\n        });\n        frm.refresh_fields([TABLES.earnings, TABLES.deductions]);\n      }\n\n      // Recompute using effective base; if custom_offered_ctc > 0, overwrite all formula rows\n      recompute_all_amounts(frm);\n      frappe.show_progress(\"Loading\", 100, 100, \"Done\");\n    } catch (e) {\n      console.error(e);\n      frappe.msgprint({\n        title: \"Failed\",\n        message: e?.message || \"Could not load components from Salary Structure.\",\n        indicator: \"red\",\n      });\n    } finally {\n      frappe.hide_progress();\n    }\n  }\n\n  frappe.ui.form.on(\"Job Offer\", {\n    salary_structure(frm) {\n      if (frm.doc.salary_structure) {\n        apply_salary_structure(frm, { overwrite: true });\n      } else {\n        frm.clear_table(TABLES.earnings);\n        frm.clear_table(TABLES.deductions);\n        frm.refresh_fields([TABLES.earnings, TABLES.deductions]);\n      }\n    },\n\n    // Recompute when base changes\n    [PARENT_BASE_FIELD](frm) {\n      recompute_all_amounts(frm);\n    },\n\n    // NEW: Recompute when custom_offered_ctc changes (and drive all formulas from it)\n    [CUSTOM_OFFERED_CTC](frm) {\n      recompute_all_amounts(frm);\n    },\n\n    refresh(frm) {\n      if (!frm.doc.salary_structure) {\n        frm.dashboard.clear_headline();\n        frm.dashboard.set_headline(\n          `<span class=\"text-muted\">Select a Salary Structure to populate earnings & deductions.</span>`\n        );\n      }\n      recompute_all_amounts(frm);\n    },\n  });\n})();\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Job Offer",
  "enabled": 1,
  "modified": "2025-09-08 23:47:03.170335",
  "module": "fbts",
  "name": "CTC Validation",
  "script": "frappe.ui.form.on(\"Job Offer\", {\n  validate(frm) {\n    const offered = flt(frm.doc.custom_offered_ctc || 0);\n    const base = flt(frm.doc.base || 0);\n\n    if (offered && base && offered < base) {\n      frappe.throw(\n        __(\"Offered CTC ({0}) cannot be less than Base ({1}).\", [\n          offered,\n          base,\n        ])\n      );\n    }\n  },\n});\n",
  "view": "Form"
 }
]